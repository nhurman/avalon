\section{Tests}

\subsection{Tests unitaires}
Au cours de notre formation, nous avons essentiellement utilisé les tests unitaires qui sont bien adaptés aux programmes clairement découpés en fonctions.
Dans notre cas, il ne nous est pas possible de procéder ainsi de manière efficace car l'essentiel du programme est dans le graphe de scène de Unity3D. \newline

Dans le cas de Unity3D, l'écriture de code n'intervient que dans des scripts en C\# qui ne représentent pas l'intégralité du projet. De plus, leur exécution est principalement liée au graphe de scène et aux actions de l'utilisateur dans l'univers 3D, ce qui n'est pas réellement unitairement testable.\newline

Unity3D propose tout de même un ensemble d'outils de test, qui permet entre autres de réaliser des tests unitaires, mais les délais du projet ne nous ont pas permis les prendre en main. Les tests que nous avons réalisé au long de notre projet sont donc principalement des tests fonctionnels et d'acceptation. 

\subsection{Tests fonctionnels}
Les tests fonctionnels représentent la majorité de ceux que nous avons menés au cours du projet Avalon. Faciles à mettre en place, ils nous assurent qu'une modification n'entraîne pas une régression inattendue. Nous vérifions chaque fonctionnalité indépendamment, sans mettre en place un scénario d'utilisation complexe mais simplement en s'attachant à ce que le programme répond de la manière souhaitée à une situation donnée (conformité aux spécifications du projet).\newline

Au moment de son intégration, chaque fonctionnalité a été testée, ainsi qu'à chaque fois qu'une modification était suceptible de l'impacter. À titre d'exemple, nous avons testé les déplacements au clavier/souris quand nous avons créé le script utilisé, puis plus tard quand nous avons modifié la manière de contrôler le curseur à l'écran. Nous avons fait de même quand nous avons créé une zone où l'utilisateur perd le contrôle de ses déplacements et est déplacé \enquote{sur des rails}.\newline

L'avantage principal de ce type de tests est sa facilité, il nous permet de tester chaque fonctionnalité indépendamment et en temps réel. En contrepartie nous courrons le risque de ne pas remarquer cetains cas d'erreur qui n'apparaissent pas clairement, d'une part parce qu'étant les concepteurs des fonctionnalités en question nous avons un \textit{a priori} quant à la façon dont il faut s'en servir, et d'autre part parce que nous ne pouvons pas penser à tous les cas exotiques.

\subsection{Tests d'acceptation}
Les tests d'acceptation représentent la seconde catégorie de tests que nous avons appliqués. Moins fréquents que les tests fonctionnels, ils sont plus intensifs. \newline

Les tests d'acceptation vérifient le fonctionnement en interaction d'un grand nombre de \textit{features} et sanctionnent une avancée significative du projet. Il s'agit généralement de tester un scénario d'utilisation réaliste qu'un usager serait suceptible de réaliser par lui-même sans connaître les détils d'implémentation du projet. \newline

Pour reprendre les exemples du point précédent, une fois toutes les fonctionnalités mentionnées disponibles, nous avons essayé d'apparaître dans la scène, se déplacer librement quelques instants, puis se rendre dans la zone où l'on perdait le contrôle du personnage et en repartir, le tout sans qu'il n'y ait de problème de collision (i.e. traverser un mur ou se glisser dans l'interstice d'une porte). 
