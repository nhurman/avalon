\section{\label{modelisation}Modélisation}

\subsection{Diagramme des cas d’utilisations}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{4-Conception/img/diagCasUsage.png}
    \caption{Diagramme de cas d'utilisation : Menus}
\end{figure}

\subsection{Diagramme de séquence}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{4-Conception/img/diagSequenceLight.png}
    \caption{Diagramme de séquence : déroulement d'une interaction}
    \label{fig:sequence_diagram}
\end{figure}

\subsection{Diagramme de classes C\#}

\begin{landscape}
  \begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth]{4-Conception/img/diagClasses.png}
    \caption{Diagramme de classes}
    \label{fig:class_diagram}
  \end{figure}
\end{landscape}

\subsubsection{Généralités}
Dans cette partie, il sera souvent fait mention du terme GameObject; il s'agit d'un élément Unity. 
Celui ci peut-être graphique ou non, généré à l'execution, contenir d'autres GameObject (comme un dossier) et contenir des scripts qui lui sont associés.

Dans Unity, tout script doit hériter de la classe MonoBehaviour.
Celle ci implémente les fonctions que tout les scripts Unity doivent avoir, comme le rafraichissement à chaque image ou pas de temps, le réveil/endormissement ou la gestion de la souris.
Cette classe nous permettra surtout d'accéder au GameObject le contenant et aux autres scripts du même GameObject.

\subsubsection{Menus}
Sur le diagramme, une classe UI\_Menu est présente. Elle représente les classes d'interface que nous utiliserons pour afficher des menus d'informations à l'utilisateur.
Nous utiliserons de préférence les classes rajoutées par la dernière version de MiddleVR (1.6.0), car adaptées à la 3D dans un environnement de réalité virtuelle (comment afficher un menu quand l'utilisateur est debout et peut tourner la tête?).

Cette version étant disponible seulement depuis la semaine précédente, nous n'avons pas eu l'occasion d'étudier l'architecture proposée pour cette partie.
Dans le cas où nous ne pourrions intégrer ces fonctionnalités, nous utiliserons une manière plus basique pour l'affichage, telle que des textures appliqués sur des plans.

La classe \textit{RemoteCommand} permet d'afficher la télécommande qui contrôle les équipements domotiques. Elle utilisera si possible les classes d'interface MiddleVR, et permettra d'interagir avec l'appartement.


\subsubsection{Elements activables}
On distingue deux types d'éléments sur lesquels on peut interagir : ceux avec un état binaire (interrupteur on/off), et ceux avec un état variable, comme la table et sa hauteur. Tous les cas simples seront gérés par des ToggleElement. Les différences entre chaque sous classe se résument à des détails de l'objet.

Une lumière allumée ou éteinte n'est pas gérée de la même manière que la hauteur d'un volet. La classe VariableElement permet de gérer les GameObjects avec une valeur interne ; il est possible de d'augmenter les variables de manière incrémentale ou de fixer une valeur directement.

Cette classe inclue une valeur minimale et maximale pour la valeur contrainte, ainsi qu'un pas de déplacement. Ce pas permet de régler le changement de valeur à chaque clic ; par exemple, on choisira 1cm dans le cas de la table, pour que le déplacement soit cohérent avec la réalité.

Ce modèle prend aussi en compte les spécificités relatives aux différents éléments, comme la propriété \textit{BlockedState} des portes qui permet de savoir où le mouvement de la porte à été stoppé la dernière fois, pour ralentir lors du prochain essai.

Toutes ces classes, comme \textit{VariableLight}, \textit{Shutter} ou \textit{Table},  ne disposent pas de variable modélisant leur état courant. Il faut prendre en compte que ce sont des scripts associés à un objet 3D. La valeur actuelle (de hauteur dans le cas de la table par exemple) correspond à une ou plusieurs caractéristiques graphiques de l'objet.

\subsubsection{GameManager}
Pour toutes les informations et les fonctionnalités non liées à un objet en particulier (souvent encapsulées dans un singleton dans un contexte objet), les developpeurs Unity préconisent d'associer des scripts à un GameObject n'ayant pas d'éléments graphiques et ne contenant pas d'autres GameObject.

L'accès à ces éléments se fait via le nom du GameObject les contenant, ou via des tags référençant l'élément. Ce GameObject doit être unique ce qui fait que la classe GameManager s'apparente dans l'utilisation à un singleton (bien que n'en étant pas un).

Elle contient des informations sur le scénario en cours, le nombre d'erreurs \textit{NumberError} et que faire s'il y a trop d'erreurs de le part de l'utilisateur (\textit{onError}).

Le passage à l'étape suivante d'un scénario se fait grace aux informations transmises par les scripts des GameObjects via la fonction \textit{NotifyGameManager} et à la fonction \textit{NextStep}.
